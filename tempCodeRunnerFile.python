from ecdsa import SECP256k1
import os

# -----------------------------
# Initialisation
# -----------------------------
curve = SECP256k1.curve
G = SECP256k1.generator
order = SECP256k1.order

# Clés d'Alice (destinataire)
d_A = int.from_bytes(os.urandom(32), 'big') % order  # clé privée
Q_A = d_A * G                                       # clé publique

# -----------------------------
# Mapping public simple
# -----------------------------
def message_to_point(msg):
    """Convertit un message texte en point sur la courbe"""
    m_int = int.from_bytes(msg.encode(), 'big')
    return m_int * G

def point_to_message(P):
    """Récupère le texte original à partir d'un point"""
    m_int = P.x() % order
    return m_int.to_bytes((m_int.bit_length() + 7) // 8, 'big').decode()

# -----------------------------
# Chiffrement
# -----------------------------
def encrypt_elgamal_ec(message, Q_A):
    k = int.from_bytes(os.urandom(32), 'big') % order
    C1 = k * G
    M = message_to_point(message)
    C2 = M + k * Q_A
    return C1, C2

# -----------------------------
# Déchiffrement
# -----------------------------
def decrypt_elgamal_ec(C1, C2, d_A):
    M_point = C2 - d_A * C1
    return point_to_message(M_point)

# -----------------------------
# Test complet
# -----------------------------
message = input("Entrez le message à chiffrer : ")
C1, C2 = encrypt_elgamal_ec(message, Q_A)
decrypted_message = decrypt_elgamal_ec(C1, C2, d_A)

print("Message original :", message)
print("Message chiffré (points C1, C2) :")
print("C1 =", C1)
print("C2 =", C2)
print("Message déchiffré :", decrypted_message)
